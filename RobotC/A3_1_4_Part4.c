#pragma config(Sensor, in1,    lineFollower,   sensorLineFollower)
#pragma config(Sensor, in2,    potentiometer,  sensorPotentiometer)
#pragma config(Sensor, in3,    lightSensor,    sensorReflection)
#pragma config(Sensor, dgtl1,  limitSwitch,    sensorTouch)
#pragma config(Sensor, dgtl2,  bumpSwitch,     sensorTouch)
#pragma config(Sensor, dgtl3,  quad,           sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  sonar,          sensorSONAR_cm)
#pragma config(Sensor, dgtl10, gLED,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl11, smsb,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, slsb,           sensorLEDtoVCC)
#pragma config(Motor,  port1,           flashlight,    tmotorVexFlashlight, openLoop, reversed)
#pragma config(Motor,  port2,           motorRight,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           motorLeft,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           motorServo,    tmotorServoStandard, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
Project Title: Activity 3.1.4 While and If-else structures
Team Members: DeShawn Turner, Jordan Yoon-Buck
Date: February 21, 2017
Section: POE B1
*/

/** getCurrentSelection(): int
 *  returns the program selected using the potentiometer: 1, 2, 3, or 4
 */
int getCurrentSelection() {
  int selection = 0;
  int rotation = SensorValue(potentiometer);
  if (rotation <= 1024) {
    selection = 1;
  } else if (rotation <= 2048) {
    selection = 2;
  } else if (rotation <= 3072) {
    selection = 3;
  } else {
    selection = 4;
  }
  return selection;
}

/** makeSelection(): int
 *  allows the user to select a program using the potentiometer.
 *  shows the current program selected on the green LEDs
 *  confirms and returns the selection when the bump switch is pressed.
 */
int makeSelection() {
  int selection;
  while(!SensorValue(bumpSwitch)) {
    selection = getCurrentSelection();
    if (selection > 2) {
      turnLEDOn(smsb);
    } else {
      turnLEDOff(smsb);
    }
    if (selection == 2 || selection == 4) {
      turnLEDOn(slsb);
    } else {
      turnLEDOff(slsb);
    }
  }
  return selection;
}

/** Program A
 *  Make a motor spin as long as the bump switch is being held down.
 *  Its direction depends on whether a person is within 20 cm of the
 *  ultrasonic sensor. If the button is released, the behavior will
 *  repeat if it is pressed again.
 */
void programA() {
  int thisSelection = 1;
  while (getCurrentSelection() == thisSelection) {
    while (SensorValue(bumpSwitch) && getCurrentSelection() == thisSelection) {
      if (SensorValue(sonar) <= 20 && SensorValue(sonar) != -1) {
        motor[motorLeft] = motor[motorRight] = -127;
      } else {
        motor[motorLeft] = motor[motorRight] = 127;
      }
    }
    motor[motorLeft] = motor[motorRight] = 0;
  }
}

/** Program B
 *  Make the servo position itself to the left or right depending on
 *  whether the line follower is covered by your hand.
 */
void programB() {
  int thisSelection = 2;
  while (getCurrentSelection() == thisSelection) {
    if (SensorValue(lineFollower) < 3000) {
      motor[motorServo] = -127;
    } else {
      motor[motorServo] = 127;
    }
  }
}

/** Program C
 *  Make the servo position itself to the left or right depending on
 *  whether the line follower is covered by your hand. This behavior will
 *  only apply if the button is pressed; if the button is released, the
 *  servo is in a middle position, awaiting the button to be pressed again.
 */
void programC() {
  int thisSelection = 3;
  while (getCurrentSelection() == thisSelection) {
    if (!SensorValue(bumpSwitch)) {
      motor[motorServo] = 0;
    } else if (SensorValue(lineFollower) < 3000) {
      motor[motorServo] = -127;
    } else {
      motor[motorServo] = 127;
    }
  }
}

/** Program D
 *  Make one motor spin whenever a button is pressed and a second motor
 *  spin whenever a limit switch is pressed. This behavior repeats
 *  indefinitely, as the two actions are independent.
 */
void programD() {
  int thisSelection = 4;
  while (getCurrentSelection() == thisSelection) {
    if (SensorValue(bumpSwitch)) {
      motor[motorRight] = 127;
    } else {
      motor[motorRight] = 0;
    }
    if (SensorValue(limitSwitch)) {
      motor[motorLeft] = 127;
    } else {
      motor[motorLeft] = 0;
    }
  }
}

/** main task
 *  repeat forever: make a selection, execute that program.
 */
task main() {
	int selection;
	while(1) {
    turnLEDOff(gLED);
    motor[motorLeft] = motor[motorRight] = 0;
    while (SensorValue(bumpSwitch)) {
      turnLEDOn(gLED);
      wait(0.1);
      turnLEDOff(gLED);
      wait(0.1);
    }
		selection = 0;
	  selection = makeSelection();
    turnLEDOn(gLED);
    while (SensorValue(bumpSwitch)) {
      turnLEDOn(gLED);
    };
    switch(selection) {
      case 1:
        programA();
        break;
      case 2:
        programB();
        break;
      case 3:
        programC();
        break;
      case 4:
        programD();
        break;
    }
	}
}
