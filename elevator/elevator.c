#pragma config(Sensor, dgtl1,  count,          sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  call0,          sensorTouch)
#pragma config(Sensor, dgtl4,  call1,          sensorTouch)
#pragma config(Sensor, dgtl5,  call2,          sensorTouch)
#pragma config(Sensor, dgtl7,  ind0,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl8,  ind1,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl9,  ind2,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, resetSw,         sensorTouch)
#pragma config(Motor,  port1,           driver,        tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
 * Project 3.1.7 Machine Control Design (VEX)
 * Jordan Yoon-Buck, DeShawn Turner
 * Date: April 7, 2017
 * Section: POE B1
 */

// these are the vaules of the encoder for each floor.
// they can also be found using calibrate()
int floors[3] = {74, 258, 454};

// hoist this function. defined in this file, but used in some of the others.
int lifecycle(bool isMoving);

#include "utilities.c"
#include "indicators.c"
#include "queue.c"
#include "motion.c"

// contains the current floor.
int current = 0;

// delay in milliseconds after traveling to each floor
int floorDelay = 2500;

// delay in milliseconds before returning to floor one (includes floor delay)
int resetDelay = 10000;

// main loop
task main() {

	calibrate();

	while (SensorValue[resetSw]) {}

  // to start, reset everything.
  // moves down and recalibrates the floors.
  doReset();

  int next;

  while (1) {
    // lifecycle is truthy if a floor is selected.
    if (lifecycle(false)) {
      // the current floor shouldn't be queued.
      dequeue(current);
      // as long as the queue is not empty:
      while (queue[0] || queue[1] || queue[2]) {
        // find out where to go next.
        next = getNextTarget(current);
        if (~next) {
          // turn the current indicator off
          indMode[current] = 0;
          current = next;
          // go to this floor
          goToFloor(next);
          // wait for the appropriate delay
          clearTimer(0);
          while (time1[0] < floorDelay) {
            lifecycle(false);
          }
        }
        // again, remove the current floor from the queue.
        // likely redundant to goToFloor(), as a fallback to prevent this
        // loop from going forever and keeping the cart only on one floor.
        dequeue(current);
      }
    }
    // otherwise, if we're just idling,
    // return to floor 0 after the appropriate delay
    if ((time1[0] > resetDelay) && current) {
    	goToFloor(0);
      current = 0;
    }
  }

}

int lifecycle(bool isMoving) {
  // update the indicator lights
  doIndicateTick();
  int ret = 0;
  // queue floors for any buttons pressed
  if (SensorValue[call0]) {
    ret++;
    queue[0] = true;
    indMode[0] = 4;
  }
  if (SensorValue[call1]) {
    ret++;
    queue[1] = true;
    indMode[1] = 4;
  }
  if (SensorValue[call2]) {
    ret++;
    queue[2] = true;
    indMode[2] = 4;
  }
  // if the reset button is pressed, and the elevator is not active,
  // reset and recalibrate
  if (SensorValue[resetSw] && !isMoving) {
    indMode[0] = indMode[1] = indMode[2] = 2;
    // wait until the reset button is not pressed
    while (SensorValue[resetSw]) {
      doIndicateTick();
    }
    // perform the reset
    doReset();
    current = 0;
  }
  return ret;
}
